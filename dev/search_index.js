var documenterSearchIndex = {"docs":
[{"location":"controls/#A-first-example:-GUI-controls","page":"A first example: GUI controls","title":"A first example: GUI controls","text":"","category":"section"},{"location":"controls/","page":"A first example: GUI controls","title":"A first example: GUI controls","text":"Let's create a slider object:","category":"page"},{"location":"controls/","page":"A first example: GUI controls","title":"A first example: GUI controls","text":"julia> using Gtk4, GtkObservables\n\njulia> sl = slider(1:11)\nGtkScaleLeaf with Observable(6)\n\njulia> typeof(sl)\nGtkObservables.Slider{Int64}","category":"page"},{"location":"controls/","page":"A first example: GUI controls","title":"A first example: GUI controls","text":"A GtkObservables.Slider holds two important objects: an Observable (encoding the \"state\" of the widget) and a GtkWidget (which controls the on-screen display). We can extract both of these components:","category":"page"},{"location":"controls/","page":"A first example: GUI controls","title":"A first example: GUI controls","text":"julia> observable(sl)\nObservable(6)\n    0 => (::GtkObservables.var\"#9#10\")(val)\n\njulia> typeof(widget(sl))\nGtkScaleLeaf","category":"page"},{"location":"controls/","page":"A first example: GUI controls","title":"A first example: GUI controls","text":"(If you omitted the typeof, you'd instead see a long display that encodes the settings of the GtkScaleLeaf widget.)","category":"page"},{"location":"controls/","page":"A first example: GUI controls","title":"A first example: GUI controls","text":"At present, this slider is not affiliated with any window. Let's create one and add the slider to the window. We'll put it inside a Box so that we can later add more things to this GUI (this illustrates usage of some of Gtk's layout tools:","category":"page"},{"location":"controls/","page":"A first example: GUI controls","title":"A first example: GUI controls","text":"julia> win = GtkWindow(\"Testing\"); win[] = bx = GtkBox(:v);  # a window containing a vertical Box for layout\n\njulia> push!(bx, sl);    # put the slider in the box, shorthand for push!(bx, widget(sl))","category":"page"},{"location":"controls/","page":"A first example: GUI controls","title":"A first example: GUI controls","text":"You should now see a window with your slider in it:","category":"page"},{"location":"controls/","page":"A first example: GUI controls","title":"A first example: GUI controls","text":"(Image: slider1)","category":"page"},{"location":"controls/","page":"A first example: GUI controls","title":"A first example: GUI controls","text":"The value should be 6, set to the median of the range 1:11 that we used to create sl. Now drag the slider all the way to the right, and then see what happened to sl:","category":"page"},{"location":"controls/","page":"A first example: GUI controls","title":"A first example: GUI controls","text":"DocTestSetup = quote\n    sl[] =  11    # Updates the value of a Observable. See the Observables.jl docs.\nend","category":"page"},{"location":"controls/","page":"A first example: GUI controls","title":"A first example: GUI controls","text":"julia> sl\nGtkScaleLeaf with Observable(11)","category":"page"},{"location":"controls/","page":"A first example: GUI controls","title":"A first example: GUI controls","text":"You can see that dragging the slider caused the value of the observable to update. Let's do the converse, and set the value of the slider programmatically:","category":"page"},{"location":"controls/","page":"A first example: GUI controls","title":"A first example: GUI controls","text":"julia> sl[] = 1  # shorthand for observable(sl)[] = 1\n1","category":"page"},{"location":"controls/","page":"A first example: GUI controls","title":"A first example: GUI controls","text":"DocTestSetup = quote\n    sleep(0.1)   # GTK's main loop needs to iterate for the slider to be updated\nend","category":"page"},{"location":"controls/","page":"A first example: GUI controls","title":"A first example: GUI controls","text":"Now if you check the window, you'll see that the slider is at 1.","category":"page"},{"location":"controls/","page":"A first example: GUI controls","title":"A first example: GUI controls","text":"Realistic GUIs may have many different widgets. Let's add a second way to adjust the value of that observable, by allowing the user to type a value into a textbox:","category":"page"},{"location":"controls/","page":"A first example: GUI controls","title":"A first example: GUI controls","text":"julia> tb = textbox(Int; observable=observable(sl))\nGtkEntryLeaf with Observable(1)\n\njulia> push!(bx, tb);","category":"page"},{"location":"controls/","page":"A first example: GUI controls","title":"A first example: GUI controls","text":"(Image: slider2)","category":"page"},{"location":"controls/","page":"A first example: GUI controls","title":"A first example: GUI controls","text":"Here we created the textbox in a way that shared the observable of sl with the textbox; consequently, the textbox updates when you move the slider, and the slider moves when you enter a new value into the textbox. Setting the value of observable(sl) updates both.","category":"page"},{"location":"controls/","page":"A first example: GUI controls","title":"A first example: GUI controls","text":"Another example of connecting a widget with a observable is using a button to allow updates to propagate to a second Observable:","category":"page"},{"location":"controls/","page":"A first example: GUI controls","title":"A first example: GUI controls","text":"a = button(\"a\")\nx = Observable(1)\ny_temp = map(sin, x)    # see the Observables.jl documentation for info about using `map`\ny = map(_ -> y_temp[], a)","category":"page"},{"location":"controls/","page":"A first example: GUI controls","title":"A first example: GUI controls","text":"Setting x will update y_temp, but not y. Only after the user presses on the a button does y get updated with the last value of y_temp.","category":"page"},{"location":"zoom_pan/#Zoom-and-pan","page":"Zoom and pan","title":"Zoom and pan","text":"","category":"section"},{"location":"zoom_pan/","page":"Zoom and pan","title":"Zoom and pan","text":"In addition to low-level canvas support, GtkObservables also provides high-level functions to make it easier implement rubber-banding, pan, and zoom functionality.","category":"page"},{"location":"zoom_pan/","page":"Zoom and pan","title":"Zoom and pan","text":"To illustrate these tools, let's first open a window with a drawing canvas:","category":"page"},{"location":"zoom_pan/","page":"Zoom and pan","title":"Zoom and pan","text":"julia> using Gtk4, GtkObservables, TestImages\n\njulia> win = GtkWindow(\"Image\");\n\njulia> c = canvas(UserUnit);\n\njulia> push!(win, c);","category":"page"},{"location":"zoom_pan/","page":"Zoom and pan","title":"Zoom and pan","text":"As explained in A simple drawing program, the UserUnit specifies that mouse pointer positions will be reported in the units we specify, through a set_coordinates call below.","category":"page"},{"location":"zoom_pan/","page":"Zoom and pan","title":"Zoom and pan","text":"Now let's load an image to draw into the canvas:","category":"page"},{"location":"zoom_pan/","page":"Zoom and pan","title":"Zoom and pan","text":"julia> image = testimage(\"lighthouse\");","category":"page"},{"location":"zoom_pan/","page":"Zoom and pan","title":"Zoom and pan","text":"For what follows, it may be worth reminding readers that julia arrays are indexed as image[row, column], whereas for graphics we usually think in terms of (x, y). Since x corresponds to column and y corresponds to row, some operations will require that we swap the first and second indices.","category":"page"},{"location":"zoom_pan/","page":"Zoom and pan","title":"Zoom and pan","text":"Zoom and pan interactions all work through a ZoomRegion observable; let's create one for this image:","category":"page"},{"location":"zoom_pan/","page":"Zoom and pan","title":"Zoom and pan","text":"julia> zr = Observable(ZoomRegion(image))\nObservable(ZoomRegion{RoundingIntegers.RInt64}(XY(1 .. 768, 1 .. 512), XY(1 .. 768, 1 .. 512)))","category":"page"},{"location":"zoom_pan/","page":"Zoom and pan","title":"Zoom and pan","text":"The key thing to note here is that it has been created for the intervals 1..768 (corresponding to the width of the image) and 1..512 (the height of the image). Let's now create a view of the image as a Observable:","category":"page"},{"location":"zoom_pan/","page":"Zoom and pan","title":"Zoom and pan","text":"julia> imgroi = map(zr) do r\n           cv = r.currentview   # extract the currently-selected region\n           # Create a SubArray covering just the selected region (see `?view`)\n           view(image, UnitRange{Int}(cv.y), UnitRange{Int}(cv.x))\n       end;","category":"page"},{"location":"zoom_pan/","page":"Zoom and pan","title":"Zoom and pan","text":"imgroi is a Observable that holds a \"sub-image,\" one that updates any time zr is modified. We then define a draw method for the canvas that paints this selection to the canvas:","category":"page"},{"location":"zoom_pan/","page":"Zoom and pan","title":"Zoom and pan","text":"julia> redraw = draw(c, imgroi, zr) do cnvs, img, r\n           # Copy the pixel data to the canvas. Because `img` is the value of `imgroi`,\n           # this will only copy the region that was selected by the `view` call above.\n           copy!(cnvs, img)\n           # Here we set the coordinates of the canvas to correspond\n           # to the selected region of the image. This ensures that\n           # every point on the canvas has coordinates that correspond\n           # to the same position in the image.\n           set_coordinates(cnvs, r)\n       end;","category":"page"},{"location":"zoom_pan/","page":"Zoom and pan","title":"Zoom and pan","text":"We won't need to do anything further with redraw, but as a reminder: by assigning it to a variable we ensure it won't be garbage-collected (if that happened, the canvas would stop updating when imgroi and/or zr update).","category":"page"},{"location":"zoom_pan/","page":"Zoom and pan","title":"Zoom and pan","text":"Now, let's see our image:","category":"page"},{"location":"zoom_pan/","page":"Zoom and pan","title":"Zoom and pan","text":"(Image: image1)","category":"page"},{"location":"zoom_pan/","page":"Zoom and pan","title":"Zoom and pan","text":"We could change the value of zr and see the image update:","category":"page"},{"location":"zoom_pan/","page":"Zoom and pan","title":"Zoom and pan","text":"julia> zr[] = (100:300, axes(image, 2))\n(100:300, Base.OneTo(768))","category":"page"},{"location":"zoom_pan/","page":"Zoom and pan","title":"Zoom and pan","text":"(Image: image2)","category":"page"},{"location":"zoom_pan/","page":"Zoom and pan","title":"Zoom and pan","text":"More useful is to couple zr to mouse actions. Let's turn on both zooming (with init_zoom_rubberband) and panning (with init_pan_drag):","category":"page"},{"location":"zoom_pan/","page":"Zoom and pan","title":"Zoom and pan","text":"julia> rb = init_zoom_rubberband(c, zr)\nDict{String, Any} with 5 entries:\n  \"drag\"    => ObserverFunction(#179, Observable{MouseButton{UserUnit}} with 1 …\n  \"init\"    => ObserverFunction(#178, Observable{MouseButton{UserUnit}} with 1 …\n  \"active\"  => Observable{Bool} with 0 listeners. Value:…\n  \"finish\"  => ObserverFunction(#180, Observable{MouseButton{UserUnit}} with 1 …\n  \"enabled\" => Observable{Bool} with 0 listeners. Value:…\n\njulia> pandrag = init_pan_drag(c, zr)\nDict{String, Any} with 5 entries:\n  \"drag\"    => ObserverFunction(#169, Observable{MouseButton{UserUnit}} with 2 …\n  \"init\"    => ObserverFunction(#168, Observable{MouseButton{UserUnit}} with 2 …\n  \"active\"  => Observable{Bool} with 0 listeners. Value:…\n  \"finish\"  => ObserverFunction(#170, Observable{MouseButton{UserUnit}} with 2 …\n  \"enabled\" => Observable{Bool} with 0 listeners. Value:…","category":"page"},{"location":"zoom_pan/","page":"Zoom and pan","title":"Zoom and pan","text":"Now hold down your Ctrl key on your keyboard, click on the image, and drag to select a region of interest. You should see the image zoom in on that region. Then try clicking your mouse (without holding Ctrl) and drag; the image will move around, following your mouse. Double-click on the image while holding down Ctrl to zoom out to full view. The use of these modifier keys can be customized through keyword arguments to init_zoom_rubberband and init_pan_drag.","category":"page"},{"location":"zoom_pan/","page":"Zoom and pan","title":"Zoom and pan","text":"The returned dictionaries have a number of signals necessary for internal operations. Perhaps the only important user-level element is enabled; if you rb[\"enabled\"][] = false then you can (temporarily) turn off rubber-band initiation.","category":"page"},{"location":"zoom_pan/","page":"Zoom and pan","title":"Zoom and pan","text":"If you have a wheel mouse, you can activate additional interactions with init_zoom_scroll and init_pan_scroll.","category":"page"},{"location":"drawing/#A-simple-drawing-program","page":"A simple drawing program","title":"A simple drawing program","text":"","category":"section"},{"location":"drawing/","page":"A simple drawing program","title":"A simple drawing program","text":"Aside from widgets, GtkObservables also adds canvas interactions, specifically handling of mouse clicks and scroll events. We can explore some of these tools by building a simple program for drawing lines.","category":"page"},{"location":"drawing/","page":"A simple drawing program","title":"A simple drawing program","text":"Let's begin by creating a window with a canvas in it:","category":"page"},{"location":"drawing/","page":"A simple drawing program","title":"A simple drawing program","text":"using GtkObservables, Colors\nusing GtkObservables.Gtk4\n\nwin = GtkWindow(\"Drawing\")\nc = canvas(UserUnit)       # create a canvas with user-specified coordinates\npush!(win, c)","category":"page"},{"location":"drawing/","page":"A simple drawing program","title":"A simple drawing program","text":"A few concepts from Cairo are important here:","category":"page"},{"location":"drawing/","page":"A simple drawing program","title":"A simple drawing program","text":"all drawing occurs on a canvas object, which corresponds to a region of a window\nCairo canvases can use two different coordinate systems: screen pixels, often called DeviceUnit, and a user-specified custom coordinate system, called UserUnit.","category":"page"},{"location":"drawing/","page":"A simple drawing program","title":"A simple drawing program","text":"Here we specified UserUnit units for our drawing and mouse-position units; we chose these to be (0,0) for the top left and (1,1) for the bottom right. With this choice, if a user resizes the window by dragging its border, our lines will stay in the same relative position.","category":"page"},{"location":"drawing/","page":"A simple drawing program","title":"A simple drawing program","text":"We're going to set this up so that a new line is started when the user clicks with the left mouse button; when the user releases the mouse button, the line is finished and added to a list of previously-drawn lines. Consequently, we need a place to store user data. We'll use Observables, so that our Canvas will be notified when there is new material to draw:","category":"page"},{"location":"drawing/","page":"A simple drawing program","title":"A simple drawing program","text":"const lines = Observable([])   # the list of lines that we'll draw\nconst newline = Observable([]) # the in-progress line (will be added to list above)","category":"page"},{"location":"drawing/","page":"A simple drawing program","title":"A simple drawing program","text":"Now, let's make our application respond to mouse-clicks. An important detail about a GtkObservables.Canvas object is that it contains a MouseHandler, accessible with c.mouse; this object contains Observables.Observable objects for mouse button press/release events, mouse movements, and scrolling:","category":"page"},{"location":"drawing/","page":"A simple drawing program","title":"A simple drawing program","text":"const drawing = Observable(false)  # this will become true if we're actively dragging\n\n# c.mouse.buttonpress is a `Observables.Observable` that updates whenever the\n# user clicks the mouse inside the canvas. The value of this observable is\n# a MouseButton which contains position and other information.\n\n# We're going to define a callback function that runs whenever the\n# button is clicked. If we just wanted to print the value of the\n# returned button object, we could just say\n#     map(println, c.mouse.buttonpress)\n# However, here our function is longer than `println`, so\n# we're going to use Julia's do-block syntax to define the function:\nsigstart = on(c.mouse.buttonpress) do btn\n    # This is the beginning of the function body, operating on the argument `btn`\n    if btn.button == 1 && btn.modifiers == 0 # is it the left button, and no shift/ctrl/alt keys pressed?\n        drawing[] = true   # activate dragging\n        newline[] = [btn.position]  # initialize the line with the current position\n    end\nend","category":"page"},{"location":"drawing/","page":"A simple drawing program","title":"A simple drawing program","text":"We assigned the output of on to a variable to prevent it from being garbage-collected. (We could use GtkObservables.gc_preserve(win, sigstart) if we wanted to keep it alive for at least as long as win is active.)","category":"page"},{"location":"drawing/","page":"A simple drawing program","title":"A simple drawing program","text":"Once the user clicks the button, drawing holds value true; from that point forward, any movement of the mouse extends the line by an additional vertex:","category":"page"},{"location":"drawing/","page":"A simple drawing program","title":"A simple drawing program","text":"sigextend = on(c.mouse.motion) do btn\n    if drawing[]      # pay attention to motion only when we're dragging\n        # extend `newline` with the most recent point\n        push!(newline[], btn.position)\n        # notify any observers -- alternatively we could reassign to newline[]\n        notify(newline)\n    end\nend","category":"page"},{"location":"drawing/","page":"A simple drawing program","title":"A simple drawing program","text":"Notice that we made this conditional on drawing.","category":"page"},{"location":"drawing/","page":"A simple drawing program","title":"A simple drawing program","text":"Finally, when the user releases the mouse button, we stop drawing, store newline in lines, and prepare for the next line by starting with an empty newline:","category":"page"},{"location":"drawing/","page":"A simple drawing program","title":"A simple drawing program","text":"sigend = on(c.mouse.buttonrelease) do btn\n    if btn.button == 1\n        drawing[] = false  # deactivate dragging\n        # append our new line to the overall list\n        push!(lines[], newline[])\n        # For the next click, make sure `newline` starts out empty\n        # We do this in a way that prevents triggering anything (yet).\n        newline.val = []\n        # Now trigger\n        notify(lines)\n    end\nend","category":"page"},{"location":"drawing/","page":"A simple drawing program","title":"A simple drawing program","text":"At this point, you could already verify that these interactions work by monitoring lines from the command line by clicking, dragging, and releasing.","category":"page"},{"location":"drawing/","page":"A simple drawing program","title":"A simple drawing program","text":"However, it's much more fun to see it in action. Let's set up a draw method for the canvas, which will be called (1) whenever the window resizes (this is arranged by Gtk4.jl), or (2) whenever lines or newline update (because we supply them as arguments to the draw function):","category":"page"},{"location":"drawing/","page":"A simple drawing program","title":"A simple drawing program","text":"# Because `draw` isn't a one-line function, we again use do-block syntax:\nredraw = draw(c, lines, newline) do cnvs, lns, newl  # the function body takes 3 arguments\n    fill!(cnvs, colorant\"white\")   # set the background to white\n    set_coordinates(cnvs, BoundingBox(0, 1, 0, 1))  # set coordinates to 0..1 along each axis\n    ctx = Gtk4.getgc(cnvs)   # gets the \"graphics context\" object (see Cairo/Gtk)\n    for l in lns\n        drawline(ctx, l, colorant\"blue\")  # draw old lines in blue\n    end\n    drawline(ctx, newl, colorant\"red\")    # draw new line in red\nend\n\nfunction drawline(ctx, l, color)\n    isempty(l) && return\n    p = first(l)\n    move_to(ctx, p.x, p.y)\n    set_source(ctx, color)\n    for i = 2:length(l)\n        p = l[i]\n        line_to(ctx, p.x, p.y)\n    end\n    stroke(ctx)\nend","category":"page"},{"location":"drawing/","page":"A simple drawing program","title":"A simple drawing program","text":"Important note: Only modify the canvas inside the draw function, and pass all observables that you want to consume as additional arguments (the example shows three, but you may pass as few or as many as you wish). Otherwise, you may find the rendering behaves unexpectedly.","category":"page"},{"location":"drawing/","page":"A simple drawing program","title":"A simple drawing program","text":"A lot of these commands come from Cairo.jl and/or Graphics.jl.","category":"page"},{"location":"drawing/","page":"A simple drawing program","title":"A simple drawing program","text":"Our application is done! Here's a picture of me in the middle of a very fancy drawing:","category":"page"},{"location":"drawing/","page":"A simple drawing program","title":"A simple drawing program","text":"(Image: drawing)","category":"page"},{"location":"drawing/","page":"A simple drawing program","title":"A simple drawing program","text":"You can play with the completed application in the examples/ folder.","category":"page"},{"location":"reference/#Reference","page":"Reference","title":"Reference","text":"","category":"section"},{"location":"reference/#Input-widgets","page":"Reference","title":"Input widgets","text":"","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"button\ncheckbox\ntogglebutton\nslider\ntextbox\ntextarea\ndropdown\nplayer","category":"page"},{"location":"reference/#GtkObservables.button","page":"Reference","title":"GtkObservables.button","text":"button(label; widget=nothing, observable=nothing)\nbutton(; label=nothing, widget=nothing, observable=nothing)\n\nCreate a push button with text-label label. Optionally provide:\n\na GtkButton widget (by default, creates a new one)\nthe (Observables.jl) observable coupled to this button (by default, creates a new observable)\n\n\n\n\n\n","category":"function"},{"location":"reference/#GtkObservables.checkbox","page":"Reference","title":"GtkObservables.checkbox","text":"checkbox(value=false; widget=nothing, observable=nothing, label=\"\")\n\nProvide a checkbox with the specified starting (boolean) value. Optionally provide:\n\na GtkCheckButton widget (by default, creates a new one)\nthe (Observables.jl) observable coupled to this checkbox (by default, creates a new observable)\na display label for this widget\n\n\n\n\n\n","category":"function"},{"location":"reference/#GtkObservables.togglebutton","page":"Reference","title":"GtkObservables.togglebutton","text":"togglebutton(value=false; widget=nothing, observable=nothing, label=\"\")\n\nProvide a togglebutton with the specified starting (boolean) value. Optionally provide:\n\na GtkCheckButton widget (by default, creates a new one)\nthe (Observables.jl) observable coupled to this button (by default, creates a new observable)\na display label for this widget\n\n\n\n\n\n","category":"function"},{"location":"reference/#GtkObservables.slider","page":"Reference","title":"GtkObservables.slider","text":"slider(range; widget=nothing, value=nothing, observable=nothing, orientation=\"horizontal\")\n\nCreate a slider widget with the specified range. Optionally provide:\n\nthe GtkScale widget (by default, creates a new one)\nthe starting value (defaults to the median of range)\nthe (Observables.jl) observable coupled to this slider (by default, creates a new observable)\nthe orientation of the slider.\n\n\n\n\n\n","category":"function"},{"location":"reference/#GtkObservables.textbox","page":"Reference","title":"GtkObservables.textbox","text":"textbox(value=\"\"; widget=nothing, observable=nothing, range=nothing, gtksignal=:activate)\ntextbox(T::Type; widget=nothing, observable=nothing, range=nothing, gtksignal=:activate)\n\nCreate a box for entering text. value is the starting value; if you don't want to provide an initial value, you can constrain the type with T. Optionally specify the allowed range (e.g., -10:10) for numeric entries, and/or provide the (Observables.jl) observable coupled to this text box. Finally, you can specify which Gtk observable (e.g. activate, changed) you'd like the widget to update with.\n\n\n\n\n\n","category":"function"},{"location":"reference/#GtkObservables.textarea","page":"Reference","title":"GtkObservables.textarea","text":"textarea(value=\"\"; widget=nothing, observable=nothing)\n\nCreates an extended text-entry area. Optionally provide a GtkTextView widget and/or the (Observables.jl) observable associated with this widget. The observable updates when you type.\n\n\n\n\n\n","category":"function"},{"location":"reference/#GtkObservables.dropdown","page":"Reference","title":"GtkObservables.dropdown","text":"dropdown(choices; widget=nothing, value=first(choices), observable=nothing, label=\"\", with_entry=true, icons, tooltips)\n\nCreate a \"dropdown\" widget. choices can be a vector (or other iterable) of options. These options might either be a list of strings, or a list of choice::String => func pairs so that an action encoded by func can be taken when choice is selected.\n\nOptionally specify\n\nthe GtkComboBoxText widget (by default, creates a new one)\nthe starting value\nthe (Observables.jl) observable coupled to this slider (by default, creates a new observable)\nwhether the widget should allow text entry\n\nExamples\n\ndd = dropdown([\"one\", \"two\", \"three\"])\n\nTo link a callback to the dropdown, use\n\ndd = dropdown((\"turn red\"=>colorize_red, \"turn green\"=>colorize_green))\non(dd.mappedsignal) do cb\n    cb(img)                     # img is external data you want to act on\nend\n\ncb does not fire for the initial value of dd; if this is desired, manually execute dd[] = dd[] after defining this action.\n\ndd.mappedsignal is a function-observable only for the pairs syntax for choices.\n\n\n\n\n\n","category":"function"},{"location":"reference/#GtkObservables.player","page":"Reference","title":"GtkObservables.player","text":"player(range; style=\"with-textbox\", id=1)\nplayer(slice::Observable{Int}, range; style=\"with-textbox\", id=1)\n\nCreate a movie-player widget. This includes the standard play and stop buttons and a slider; style \"with-textbox\" also includes play backwards, step forward/backward, and a textbox for entering a slice by keyboard.\n\nYou can create up to two player widgets for the same GUI, as long as you pass id=1 and id=2, respectively.\n\n\n\n\n\n","category":"function"},{"location":"reference/#Output-widgets","page":"Reference","title":"Output widgets","text":"","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"label","category":"page"},{"location":"reference/#GtkObservables.label","page":"Reference","title":"GtkObservables.label","text":"label(value; widget=nothing, observable=nothing)\n\nCreate a text label displaying value as a string. Optionally specify\n\nthe GtkLabel widget (by default, creates a new one)\nthe (Observables.jl) observable coupled to this label (by default, creates a new observable)\n\n\n\n\n\n","category":"function"},{"location":"reference/#Graphics","page":"Reference","title":"Graphics","text":"","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"canvas\nGtkObservables.Canvas\nGtkObservables.MouseHandler\nDeviceUnit\nUserUnit\nGtkObservables.XY\nGtkObservables.MouseButton\nGtkObservables.MouseScroll","category":"page"},{"location":"reference/#GtkObservables.canvas","page":"Reference","title":"GtkObservables.canvas","text":"canvas(U=DeviceUnit, w=-1, h=-1) - c::GtkObservables.Canvas\n\nCreate a canvas for drawing and interaction. Optionally specify the width w and height h. U refers to the units for the canvas (for both drawing and reporting mouse pointer positions), see DeviceUnit and UserUnit. See also GtkObservables.Canvas.\n\n\n\n\n\n","category":"function"},{"location":"reference/#GtkObservables.Canvas","page":"Reference","title":"GtkObservables.Canvas","text":"GtkObservables.Canvas{U}(w=-1, h=-1, own=true)\n\nCreate a canvas for drawing and interaction. The relevant fields are:\n\ncanvas: the \"raw\" Gtk widget (from Gtk4.jl)\nmouse: the MouseHandler{U} for this canvas.\n\nSee also canvas.\n\n\n\n\n\n","category":"type"},{"location":"reference/#GtkObservables.MouseHandler","page":"Reference","title":"GtkObservables.MouseHandler","text":"MouseHandler{U<:CairoUnit}\n\nA type with Observable fields for which you can map callback actions. The fields are:\n\nbuttonpress for clicks (of type MouseButton);\nbuttonrelease for release events (of type MouseButton);\nmotion for move and drag events (of type MouseButton);\nscroll for wheelmouse or track-pad actions (of type MouseScroll);\n\nU should be either DeviceUnit or UserUnit and determines the coordinate system used for reporting mouse positions.\n\n\n\n\n\n","category":"type"},{"location":"reference/#GtkObservables.DeviceUnit","page":"Reference","title":"GtkObservables.DeviceUnit","text":"DeviceUnit(x)\n\nRepresent a number x as having \"device\" units (aka, screen pixels). See the Cairo documentation.\n\n\n\n\n\n","category":"type"},{"location":"reference/#GtkObservables.UserUnit","page":"Reference","title":"GtkObservables.UserUnit","text":"UserUnit(x)\n\nRepresent a number x as having \"user\" units, i.e., whatever units have been established with calls that affect the transformation matrix, e.g., Graphics.set_coordinates or Cairo.set_matrix.\n\n\n\n\n\n","category":"type"},{"location":"reference/#GtkObservables.XY","page":"Reference","title":"GtkObservables.XY","text":"XY(x, y)\n\nA type to hold x (horizontal), y (vertical) coordinates, where the number increases to the right and downward. If used to encode mouse pointer positions, the units of x and y are either DeviceUnit or UserUnit.\n\n\n\n\n\n","category":"type"},{"location":"reference/#GtkObservables.MouseButton","page":"Reference","title":"GtkObservables.MouseButton","text":"MouseButton(position, button, clicktype, modifiers, n_press=1)\n\nA type to hold information about a mouse button event (e.g., a click). position is the canvas position of the pointer (see XY). button is an integer identifying the button, where 1=left button, 2=middle button, 3=right button. clicktype may be BUTTON_PRESS or BUTTON_RELEASE. modifiers indicates whether any keys were held down during the click; they may be any combination of SHIFT, CONTROL, or MOD1 stored as a bitfield (test with btn.modifiers & SHIFT). Multiple clicks can be handled by setting the n_press argument. For example, a double click event corresponds to n_press=2.\n\nThe fieldnames are the same as the argument names above.\n\nMouseButton{UserUnit}()\nMouseButton{DeviceUnit}()\n\nCreate a \"dummy\" MouseButton event. Often useful for the fallback to Observables's filterwhen.\n\n\n\n\n\n","category":"type"},{"location":"reference/#GtkObservables.MouseScroll","page":"Reference","title":"GtkObservables.MouseScroll","text":"MouseScroll(position, direction, modifiers)\n\nA type to hold information about a mouse wheel scroll. position is the canvas position of the pointer (see XY). direction may be UP, DOWN, LEFT, or RIGHT. modifiers indicates whether any keys were held down during the click; they may be 0 (no modifiers) or any combination of SHIFT, CONTROL, or MOD1 stored as a bitfield.\n\nMouseScroll{UserUnit}()\nMouseScroll{DeviceUnit}()\n\nCreate a \"dummy\" MouseScroll event. Often useful for the fallback to Observables's filterwhen.\n\n\n\n\n\n","category":"type"},{"location":"reference/#Pan/zoom","page":"Reference","title":"Pan/zoom","text":"","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"ZoomRegion","category":"page"},{"location":"reference/#GtkObservables.ZoomRegion","page":"Reference","title":"GtkObservables.ZoomRegion","text":"ZoomRegion(fullinds) -> zr\nZoomRegion(fullinds, currentinds) -> zr\nZoomRegion(img::AbstractMatrix) -> zr\n\nCreate a ZoomRegion object zr for selecting a rectangular region-of-interest for zooming and panning. fullinds should be a pair (yrange, xrange) of indices, an XY object, or pass a matrix img from which the indices will be taken.\n\nzr.currentview holds the currently-active region of interest. zr.fullview stores the original fullinds from which zr was constructed; these are used to reset to the original limits and to confine zr.currentview.\n\n\n\n\n\n","category":"type"},{"location":"reference/","page":"Reference","title":"Reference","text":"Note that if you create a zrsig::Observable{ZoomRegion}, then","category":"page"},{"location":"reference/","page":"Reference","title":"Reference","text":"push!(zrsig, XY(1..3, 1..5))\npush!(zrsig, (1..5, 1..3))\npush!(zrsig, (1:5, 1:3))","category":"page"},{"location":"reference/","page":"Reference","title":"Reference","text":"would all update the value of the currentview field to the same value (x = 1..3 and y = 1..5).","category":"page"},{"location":"reference/","page":"Reference","title":"Reference","text":"pan_x\npan_y\nzoom\ninit_zoom_rubberband\ninit_zoom_scroll\ninit_pan_drag\ninit_pan_scroll","category":"page"},{"location":"reference/#GtkObservables.pan_x","page":"Reference","title":"GtkObservables.pan_x","text":"pan_x(zr::ZoomRegion, frac) -> zr_new\n\nPan the x-axis by a fraction frac of the current x-view. frac>0 means that the coordinates shift right, which corresponds to a leftward shift of objects.\n\n\n\n\n\n","category":"function"},{"location":"reference/#GtkObservables.pan_y","page":"Reference","title":"GtkObservables.pan_y","text":"pan_y(zr::ZoomRegion, frac) -> zr_new\n\nPan the y-axis by a fraction frac of the current x-view. frac>0 means that the coordinates shift downward, which corresponds to an upward shift of objects.\n\n\n\n\n\n","category":"function"},{"location":"reference/#GtkObservables.zoom","page":"Reference","title":"GtkObservables.zoom","text":"zoom(zr::ZoomRegion, scaleview, pos::XY) -> zr_new\n\nZooms in (scaleview < 1) or out (scaleview > 1) by a scaling factor scaleview, in a manner centered on pos.\n\n\n\n\n\nzoom(zr::ZoomRegion, scaleview)\n\nZooms in (scaleview < 1) or out (scaleview > 1) by a scaling factor scaleview, in a manner centered around the current view region.\n\n\n\n\n\n","category":"function"},{"location":"reference/#GtkObservables.init_zoom_rubberband","page":"Reference","title":"GtkObservables.init_zoom_rubberband","text":"signals = init_zoom_rubberband(canvas::GtkObservables.Canvas,\n                               zr::Observable{ZoomRegion},\n                               initiate = btn->(btn.button == 1 && btn.clicktype == BUTTON_PRESS && btn.n_press == 1 && btn.modifiers == CONTROL),\n                               reset = btn->(btn.button == 1 && btn.clicktype == BUTTON_PRESS && btn.n_press == 2 && btn.modifiers == CONTROL),\n                               minpixels = 2)\n\nInitialize rubber-band selection that updates zr. signals is a dictionary holding the Observables.jl signals needed for rubber-banding; you can push true/false to signals[\"enabled\"] to turn rubber banding on and off, respectively. Your application is responsible for making sure that signals does not get garbage-collected (which would turn off rubberbanding).\n\ninitiate(btn) returns true when the condition for starting a rubber-band selection has been met (by default, clicking mouse button 1). The argument btn is a MouseButton event. reset(btn) returns true when restoring the full view (by default, double-clicking mouse button 1). minpixels can be used for aborting rubber-band selections smaller than some threshold.\n\n\n\n\n\n","category":"function"},{"location":"reference/#GtkObservables.init_zoom_scroll","page":"Reference","title":"GtkObservables.init_zoom_scroll","text":"signals = init_zoom_scroll(canvas::GtkObservables.Canvas,\n                           zr::Observable{ZoomRegion},\n                           filter::Function = evt->evt.modifiers == CONTROL,\n                           focus::Symbol = :pointer,\n                           factor = 2.0,\n                           flip = false)\n\nInitialize zooming-by-mouse-scroll for canvas and update zr. signals is a dictionary holding the Observables.jl signals needed for scroll-zooming; you can push true/false to signals[\"enabled\"] to turn scroll-zooming on and off, respectively. Your application is responsible for making sure that signals does not get garbage-collected (which would turn off scroll-zooming).\n\nfilter is a function that returns true when the conditions for scroll-zooming are met; the argument is a MouseScroll event. The default is to hold down the CONTROL key while scrolling the mouse.\n\nThe focus keyword controls how the zooming progresses as you scroll the mouse wheel. :pointer means that whatever feature of the canvas is under the pointer will stay there as you zoom in or out. The other choice, :center, keeps the canvas centered on its current location.\n\nYou can change the amount of zooming via factor and the direction of zooming with flip.\n\n\n\n\n\n","category":"function"},{"location":"reference/#GtkObservables.init_pan_drag","page":"Reference","title":"GtkObservables.init_pan_drag","text":"signals = init_pan_drag(canvas::GtkObservables.Canvas,\n                        zr::Observable{ZoomRegion},\n                        initiate = btn->(btn.button == 1 && btn.clicktype == BUTTON_PRESS && btn.modifiers == 0))\n\nInitialize click-drag panning that updates zr. signals is a dictionary holding the Observables.jl signals needed for pan-drag; you can push true/false to signals[\"enabled\"] to turn it on and off, respectively. Your application is responsible for making sure that signals does not get garbage-collected (which would turn off pan-dragging).\n\ninitiate(btn) returns true when the condition for starting click-drag panning has been met (by default, clicking mouse button 1). The argument btn is a MouseButton event.\n\n\n\n\n\n","category":"function"},{"location":"reference/#GtkObservables.init_pan_scroll","page":"Reference","title":"GtkObservables.init_pan_scroll","text":"signals = init_pan_scroll(canvas::GtkObservables.Canvas,\n                          zr::Observable{ZoomRegion},\n                          filter_x::Function = evt->evt.modifiers == SHIFT || event.direction == LEFT || event.direction == RIGHT,\n                          filter_y::Function = evt->evt.modifiers == 0 || event.direction == UP || event.direction == DOWN,\n                          xpanflip = false,\n                          ypanflip  = false)\n\nInitialize panning-by-mouse-scroll for canvas and update zr. signals is a dictionary holding the Observables.jl signals needed for scroll-panning; you can push true/false to signals[\"enabled\"] to turn scroll-panning on and off, respectively. Your application is responsible for making sure that signals does not get garbage-collected (which would turn off scroll-panning).\n\nfilter_x and filter_y are functions that return true when the conditions for x- and y-scrolling are met; the argument is a MouseScroll event. The defaults are that vertical scrolling is triggered with an unmodified scroll, whereas horizontal scrolling is triggered by scrolling while holding down the SHIFT key.\n\nYou can flip the direction of either pan operation with xpanflip and ypanflip, respectively.\n\n\n\n\n\n","category":"function"},{"location":"reference/#API","page":"Reference","title":"API","text":"","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"observable\nframe\nGtkObservables.gc_preserve","category":"page"},{"location":"reference/#GtkObservables.observable","page":"Reference","title":"GtkObservables.observable","text":"observable(w) -> obs\n\nReturn the Observable obs associated with widget w.\n\n\n\n\n\n","category":"function"},{"location":"reference/#GtkObservables.frame","page":"Reference","title":"GtkObservables.frame","text":"frame(w) -> f\n\nReturn the GtkFrame f associated with widget w.\n\n\n\n\n\n","category":"function"},{"location":"reference/#GtkObservables.gc_preserve","page":"Reference","title":"GtkObservables.gc_preserve","text":"gc_preserve(widget::GtkWidget, obj)\n\nPreserve obj until widget has been destroyed.\n\n\n\n\n\n","category":"function"},{"location":"#Introduction","page":"Introduction","title":"Introduction","text":"","category":"section"},{"location":"#Scope-of-this-package","page":"Introduction","title":"Scope of this package","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"GtkObservables is a package building on the functionality of Gtk4.jl and Observables.jl. Its main purpose is to simplify the handling of interactions among components of a graphical user interface (GUI).","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Creating a GUI generally involves some or all of the following:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"creating the controls\narranging the controls (layout) in one or more windows\nspecifying the interactions among components of the GUI\n(for graphical applications) canvas drawing\n(for graphical applications) canvas interaction (mouse clicks, drags, etc.)","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"GtkObservables is targeted primarily at items 1, 3, and 5. Layout is handled by Gtk4.jl, and drawing (with a couple of exceptions) is handled by plotting packages or at a lower level by Cairo.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"GtkObservables is suitable for:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"\"quick and dirty\" applications which you might create from the command line\nmore sophisticated GUIs where layout is specified using tools like GtkBuilder XML.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"For usage with GtkBuilder XML, the Input widgets and Output widgets defined by this package allow you to supply a preexisting widget (which you might load with GtkBuilder) rather than creating one from scratch. Users interested in using GtkObservables this way are encouraged to see how the player widget is constructed (see src/extrawidgets.jl).","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"At present, GtkObservables supports only a small subset of the widgets provided by Gtk4. It is fairly straightforward to add new ones, and pull requests would be welcome.","category":"page"},{"location":"#Concepts","page":"Introduction","title":"Concepts","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"The central concept of Observables.jl is the Observable, a type that allows updating with new values that then triggers actions that may update other Observables or execute functions. Your GUI ends up being represented as a \"graph\" of Observables that collectively propagate the state of your GUI. GtkObservables couples Observables to Gtk4.jl's widgets. In essence, Observables.jl allows ordinary Julia objects to become the triggers for callback actions; the primary advantage of using Julia objects, rather than Gtk4 widgets, as the \"application logic\" triggers is that it simplifies reasoning about the GUI and seems to reduce the number of times ones needs to consult the Gtk documentation.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Please see the Observables.jl documentation for more information.","category":"page"},{"location":"#Important-note:-The-UI-thread","page":"Introduction","title":"Important note: The UI thread","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"Changes to the UI can only be performed safely if the code is run in the same thread that the Gtk4 main loop is running on. Observable handlers may run on a different thread. If a UI update operation occurs on a different thread, the process (Julia) can crash. The solution is to wrap the offending code block with Gtk4.GLib.@idle_add, which requests Gtk4 to run the code block on the UI thread when the main loop is idle. However, this also means that code inside the block will not run synchronously with code outside it.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"on(myobs) do val\n    @idle_add begin\n        # UI update code here\n    end\n    # changes inside @idle_add block may not yet have happened here\nend","category":"page"}]
}
